name: "Commit Version"
description: "Updates a version number in a specified file and commits the change to a repository"
inputs:
  file_path:
    description: "Path to the file containing the version"
    required: true
  versions:
    description: "Comma-separated list of versions (positional to version_keys)"
    required: true
  version_keys:
    description: "Comma-separated list of version keys to update"
    required: true
  token:
    description: "GitHub token"
    required: false
    default: ""
  repository:
    description: "Target repository (owner/repo format)"
    required: false
    default: ""
  branch:
    description: "Target branch"
    required: false
    default: "development"
  commit_message:
    description: "Commit message"
    required: false
    default: "chore: update {version_pairs} in {file_path}"
  version_pattern:
    description: "Regex pattern to find version (use {key} placeholder)"
    required: false
    default: '{key}:\s*.*'
  version_replacement:
    description: "Replacement pattern (use {key} and {version} placeholders)"
    required: false
    default: '{key}: {version}'
outputs:
  success:
    description: "Whether the version was successfully updated"
    value: ${{ steps.update.outputs.success }}
  old_versions:
    description: "Comma-separated list of previous versions (aligned with version_keys order)"
    value: ${{ steps.update.outputs.old_versions }}
  new_versions:
    description: "Comma-separated list of new versions (aligned with version_keys order)"
    value: ${{ steps.update.outputs.new_versions }}
  updated_keys:
    description: "List of keys that were updated"
    value: ${{ steps.update.outputs.updated_keys }}
  version_pairs:
    description: "Comma-separated key=version pairs after update"
    value: ${{ steps.update.outputs.version_pairs }}

runs:
  using: "composite"
  steps:
    - name: Setup variables
      shell: bash
      run: |
        if [ -n "${{ inputs.repository }}" ]; then
          echo "TARGET_REPO=${{ inputs.repository }}" >> $GITHUB_ENV
        else
          echo "TARGET_REPO=${{ github.repository }}" >> $GITHUB_ENV
        fi
        
        if [ -n "${{ inputs.token }}" ]; then
          echo "TARGET_TOKEN=${{ inputs.token }}" >> $GITHUB_ENV
        elif [ -z "${{ inputs.repository }}" ]; then
          echo "TARGET_TOKEN=${{ github.token }}" >> $GITHUB_ENV
        else
          echo "Error: Token is required when targeting a different repository"
          exit 1
        fi

    - name: Checkout target repository
      uses: actions/checkout@v5
      with:
        repository: ${{ env.TARGET_REPO }}
        ref: ${{ inputs.branch }}
        token: ${{ env.TARGET_TOKEN }}
        path: target-repo

    - id: update
      name: Update version in file
      shell: bash
      working-directory: target-repo
      run: |
        FILE="${{ inputs.file_path }}"
        VERSIONS_INPUT="${{ inputs.versions }}"
        PATTERN="${{ inputs.version_pattern }}"
        REPLACEMENT="${{ inputs.version_replacement }}"
        VERSION_KEYS_INPUT="${{ inputs.version_keys }}"
        
        # Validations
        if [ -z "$FILE" ] || [ "$FILE" = " " ]; then
          echo "Error: file_path cannot be empty"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        if [ -z "$VERSIONS_INPUT" ] || [ "$VERSIONS_INPUT" = " " ]; then
          echo "Error: versions cannot be empty"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        if [ -z "$VERSION_KEYS_INPUT" ] || [ "$VERSION_KEYS_INPUT" = " " ]; then
          echo "Error: version_keys cannot be empty"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        if [ ! -f "$FILE" ]; then
          echo "Error: File $FILE not found"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi

        # Convert comma-separated string to array and trim whitespace
        IFS=',' read -ra VERSION_KEYS_ARRAY <<< "$VERSION_KEYS_INPUT"
        for i in "${!VERSION_KEYS_ARRAY[@]}"; do
          VERSION_KEYS_ARRAY[i]=$(echo "${VERSION_KEYS_ARRAY[i]}" | xargs)
        done

        # Initialize tracking variables
        UPDATED_KEYS_LIST=""
        OLD_VERSIONS_LIST=""
        NEW_VERSIONS_LIST=""
        VERSION_PAIRS_LIST=""

        IFS=',' read -ra VERSIONS_ARRAY <<< "$VERSIONS_INPUT"
        for i in "${!VERSIONS_ARRAY[@]}"; do
          VERSIONS_ARRAY[i]=$(echo "${VERSIONS_ARRAY[i]}" | xargs)
          if [ -z "${VERSIONS_ARRAY[i]}" ]; then
            echo "Error: Empty version value at position $i"
            echo "success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
        done

        if [ ${#VERSIONS_ARRAY[@]} -ne ${#VERSION_KEYS_ARRAY[@]} ]; then
          echo "Error: versions count (${#VERSIONS_ARRAY[@]}) does not match version_keys count (${#VERSION_KEYS_ARRAY[@]})"
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi
        SUCCESS_COUNT=0
        
        # Process each version key with its corresponding version
        for INDEX in "${!VERSION_KEYS_ARRAY[@]}"; do
          VERSION_KEY="${VERSION_KEYS_ARRAY[$INDEX]}"
          CURRENT_VERSION="${VERSIONS_ARRAY[$INDEX]}"
          echo "Processing version key: $VERSION_KEY -> $CURRENT_VERSION"
          
          # Replace placeholders in pattern and replacement for this key
          KEY_PATTERN=${PATTERN//\{key\}/$VERSION_KEY}
          KEY_REPLACEMENT=${REPLACEMENT//\{key\}/$VERSION_KEY}
          KEY_REPLACEMENT=${KEY_REPLACEMENT//\{version\}/$CURRENT_VERSION}

          # Extract old version for this key - handle JSON, YAML and ENV formats
          if [[ "$FILE" == *.json ]]; then
            OLD_VERSION=$(grep -oP "(?<=\"$VERSION_KEY\":\s\")[^\"]*" "$FILE" 2>/dev/null || echo "unknown")
          elif [[ "$FILE" == *.yml ]] || [[ "$FILE" == *.yaml ]]; then
            OLD_VERSION=$(grep -oP "(?<=^$VERSION_KEY:\s).*$" "$FILE" 2>/dev/null | sed 's/[[:space:]]*$//' || echo "unknown")
          else
            # Environment file format: KEY=value (fallback for .env, .properties, etc.)
            OLD_VERSION=$(grep -oP "(?<=^$VERSION_KEY=).*$" "$FILE" 2>/dev/null | sed 's/[[:space:]]*$//' || echo "unknown")
          fi
          
          echo "Updating $VERSION_KEY from '$OLD_VERSION' to '$CURRENT_VERSION' in $FILE"
          
          # Track versions and keys (comma-separated lists)
          if [ -z "$OLD_VERSIONS_LIST" ]; then
            OLD_VERSIONS_LIST="$OLD_VERSION"
            NEW_VERSIONS_LIST="$CURRENT_VERSION"
            VERSION_PAIRS_LIST="$VERSION_KEY=$CURRENT_VERSION"
          else
            OLD_VERSIONS_LIST="$OLD_VERSIONS_LIST, $OLD_VERSION"
            NEW_VERSIONS_LIST="$NEW_VERSIONS_LIST, $CURRENT_VERSION"
            VERSION_PAIRS_LIST="$VERSION_PAIRS_LIST, $VERSION_KEY=$CURRENT_VERSION"
          fi
          
          # Update version using sed for this specific key
          if sed -i.bak -E "s|$KEY_PATTERN|$KEY_REPLACEMENT|g" "$FILE"; then
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
            if [ -z "$UPDATED_KEYS_LIST" ]; then
              UPDATED_KEYS_LIST="$VERSION_KEY"
            else
              UPDATED_KEYS_LIST="$UPDATED_KEYS_LIST, $VERSION_KEY"
            fi
          else
            echo "Error: Failed to update $VERSION_KEY in $FILE"
          fi
        done
        
        # Clean up backup file if it exists
        rm -f "$FILE.bak"
        
        # Set outputs
        echo "old_versions=$OLD_VERSIONS_LIST" >> $GITHUB_OUTPUT
        echo "new_versions=$NEW_VERSIONS_LIST" >> $GITHUB_OUTPUT
        echo "updated_keys=$UPDATED_KEYS_LIST" >> $GITHUB_OUTPUT
        echo "version_pairs=$VERSION_PAIRS_LIST" >> $GITHUB_OUTPUT

        # Check overall success
        if [ $SUCCESS_COUNT -eq ${#VERSION_KEYS_ARRAY[@]} ]; then
          echo "success=true" >> $GITHUB_OUTPUT
          echo "All version keys updated successfully: $UPDATED_KEYS_LIST"
        elif [ $SUCCESS_COUNT -gt 0 ]; then
          echo "success=false" >> $GITHUB_OUTPUT
          echo "Error: Only $SUCCESS_COUNT out of ${#VERSION_KEYS_ARRAY[@]} version keys were updated successfully"
          exit 1
        else
          echo "success=false" >> $GITHUB_OUTPUT
          exit 1
        fi

    - name: Commit and push changes
      shell: bash
      working-directory: target-repo
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

        if git diff --quiet; then
          echo "No changes to commit"
          exit 0
        fi

        git add "${{ inputs.file_path }}"

        # Replace placeholders in commit message
        COMMIT_MSG="${{ inputs.commit_message }}"
        COMMIT_MSG=${COMMIT_MSG//\{file_path\}/${{ inputs.file_path }}}
        COMMIT_MSG=${COMMIT_MSG//\{version_keys\}/${{ steps.update.outputs.updated_keys }}}
        COMMIT_MSG=${COMMIT_MSG//\{versions\}/${{ steps.update.outputs.new_versions }}}
        COMMIT_MSG=${COMMIT_MSG//\{version_pairs\}/${{ steps.update.outputs.version_pairs }}}

        git commit -m "$COMMIT_MSG"
        git push origin ${{ inputs.branch }}

        echo "Changes committed and pushed successfully"
